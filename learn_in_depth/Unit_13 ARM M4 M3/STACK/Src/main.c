/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "../stm_driver/inc/Stm32_F103C6_EXTI_driver.h"
#include "../stm_driver/inc/Stm32_F103C6_gpio_driver.h"
uint16_t TaskA_Flag, TaskB_Flag ,IRQ_Flag = 0;


extern unsigned int _estack;

#define Task_A_stack_size	100  // 100 Byte
#define Task_B_stack_size	100

// Main stack
unsigned int _S_MSP = &_estack;
unsigned int _E_MSP;


// Process stack for task A
unsigned int _S_PSP_TA;
unsigned int _E_PSP_TA;

// Process stack for task B
unsigned int _S_PSP_TB;
unsigned int _E_PSP_TB;



#define OS_SET_PSP(address) 		__asm volatile("mov r0,%0 \n\t msr psp,r0" : : "r"(address))

#define OS_SWITCH_SP_to_PSP			__asm volatile("mrs r0, CONTROL \n\t orr r0,r0,#0x02 \n\t msr CONTROL, r0")

#define OS_Generate_Exception  	 	__asm volatile("SVC #0x3")

#define OS_SWITCH_SP_to_MSP			__asm volatile("mrs r0, CONTROL \n\t mov r1,#0x05 \n\t and r0,r0,r1 \n\t msr CONTROL, r0")

#define OS_SWITCH_TO_UNPRIVILIGE	__asm volatile("mrs r3,CONTROL \n\t orr r3,r3,#0x01 \n\t msr CONTROL,r3")

#define OS_SWITCH_TO_PRIVILIGE		__asm volatile("mrs r3,CONTROL \n\t lsr r3,r3,#0x1 \n\t lsl r3,r3,#0x1 \n\t msr CONTROL,r3")

typedef enum{
	PRIVILIGE,
	UNPRIVILIGE
}CPU_ACCESS_LEVEL;




void SVC_Handler()
{
	//Switch_CPU_AccessLevel(PRIVILIGE);
	OS_SWITCH_TO_PRIVILIGE;
}



// Act as the ticker of the OS
void EXTI9_CallBack(void){
	if(IRQ_Flag == 0){
		TaskA_Flag = 1;
		IRQ_Flag = 1;
	}else if(IRQ_Flag == 1){
		TaskB_Flag = 1;
		IRQ_Flag = 0;
	}
}

int TaskA(int a, int b, int c){
	return(a+b+c);
}


int TaskB(int a, int b, int c, int d){
	return(a+b+c+d);
}


void Main_OS()
{
	// Full descending stack

	// MSP
	_E_MSP = (_S_MSP - 512);   // 512 for MSP

	// PSP for Task A
	_S_PSP_TA = (_E_MSP - 8);
	// task a psp offset of main stack pointer
	_E_PSP_TA = _S_PSP_TA - Task_A_stack_size;

	// PSP for Task B
	// task b psp offset of process stack poiter
	_S_PSP_TB = (_E_PSP_TA - 8);
	_E_PSP_TB = _S_PSP_TB - Task_B_stack_size;


	// Dummy schedular
	while(1){
		__asm("NOP");
		if(TaskA_Flag == 1){
			// Set PSP register to point to the top of taskA_stack (_S_PSP_TA)
			OS_SET_PSP(_S_PSP_TA);

			// Set SP to shadow to PSP
			OS_SWITCH_SP_to_PSP;


			// Switch to user mode (unprevilige)
			//Switch_CPU_AccessLevel(UNPRIVILIGE);
			OS_SWITCH_TO_UNPRIVILIGE;


			TaskA_Flag = TaskA(1,2,3);


			// Switch to (previlige) .. via syscall, the processor will interrupt itself
			OS_Generate_Exception;

			// Set SP to shadow to MSP
			OS_SWITCH_SP_to_MSP;

		}else if(TaskB_Flag == 1){
			// Set PSP register to point to the top of taskB_stack (_S_PSP_TB)
			OS_SET_PSP(_S_PSP_TB);

			// Set SP to shadow to PSP
			OS_SWITCH_SP_to_PSP;



			// Switch to user mode (unprevilige)
			//Switch_CPU_AccessLevel(UNPRIVILIGE);
			OS_SWITCH_TO_UNPRIVILIGE;


			TaskB_Flag = TaskB(1,2,3,4);


			// Switch to (previlige)
			OS_Generate_Exception;

			// Set SP to shadow to MSP
			OS_SWITCH_SP_to_MSP;

		}
	}


}

int main(void)
{
	RCC_GPIOB_CLK_EN();
	RCC_AFIO_CLK_EN();



	EXTI_PinConfig_t EXTI_Cfg;
	EXTI_Cfg.EXTI_PIN = EXTI9PB9;
	EXTI_Cfg.TriggerCase = EXTI_Trigger_RISING;
	EXTI_Cfg.P_IRQ_CallBack = EXTI9_CallBack;
	EXTI_Cfg.IRQ_Enable = EXTI_IRQ_Enable;

	MCAL_EXTI_GPIO_Init(&EXTI_Cfg);


	Main_OS();

}

