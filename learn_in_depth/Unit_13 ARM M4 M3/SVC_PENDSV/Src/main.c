/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "../stm_driver/inc/Stm32_F103C6_EXTI_driver.h"
#include "../stm_driver/inc/Stm32_F103C6_gpio_driver.h"
#include "../CMSIS_V5/core_cm3.h"


uint16_t TaskA_Flag, TaskB_Flag ,IRQ_Flag = 0;


extern unsigned int _estack;

#define Task_A_stack_size	100  // 100 Byte
#define Task_B_stack_size	100

// Main stack
unsigned int _S_MSP = &_estack;
unsigned int _E_MSP;


// Process stack for task A
unsigned int _S_PSP_TA;
unsigned int _E_PSP_TA;

// Process stack for task B
unsigned int _S_PSP_TB;
unsigned int _E_PSP_TB;

#define OS_SET_PSP(address) 		__asm volatile("mov r0,%0 \n\t msr psp,r0" : : "r"(address))

#define OS_SWITCH_SP_to_PSP			__asm volatile("mrs r0, CONTROL \n\t orr r0,r0,#0x02 \n\t msr CONTROL, r0")

#define OS_Generate_Exception  	 	__asm volatile("SVC #0x3")

#define OS_SWITCH_SP_to_MSP			__asm volatile("mrs r0, CONTROL \n\t mov r1,#0x05 \n\t and r0,r0,r1 \n\t msr CONTROL, r0")

#define OS_SWITCH_TO_UNPRIVILIGE	__asm volatile("mrs r3,CONTROL \n\t orr r3,r3,#0x01 \n\t msr CONTROL,r3")

#define OS_SWITCH_TO_PRIVILIGE		__asm volatile("mrs r3,CONTROL \n\t lsr r3,r3,#0x1 \n\t lsl r3,r3,#0x1 \n\t msr CONTROL,r3")

typedef enum{
	PRIVILIGE,
	UNPRIVILIGE
}CPU_ACCESS_LEVEL;



// Act as the ticker of the OS
void EXTI9_CallBack(void){
	if(IRQ_Flag == 0){
		TaskA_Flag = 1;
		IRQ_Flag = 1;
	}else if(IRQ_Flag == 1){
		TaskB_Flag = 1;
		IRQ_Flag = 0;
	}
}

int TaskA(int a, int b, int c){
	return(a+b+c);
}


int TaskB(int a, int b, int c, int d){
	return(a+b+c+d);
}


void Main_OS()
{
	// Full descending stack

	// MSP
	_E_MSP = (_S_MSP - 512);   // 512 for MSP

	// PSP for Task A
	_S_PSP_TA = (_E_MSP - 8);
	_E_PSP_TA = _S_PSP_TA - Task_A_stack_size;

	// PSP for Task B
	_S_PSP_TB = (_E_PSP_TA - 8);
	_E_PSP_TB = _S_PSP_TB - Task_B_stack_size;


	// Dummy schedular
	while(1){
		__asm("NOP");
		if(TaskA_Flag == 1){
			// Set PSP register to point to the top of taskA_stack (_S_PSP_TA)
			OS_SET_PSP(_S_PSP_TA);

			// Set SP to shadow to PSP
			OS_SWITCH_SP_to_PSP;


			// Switch to user mode (unprevilige)
			//Switch_CPU_AccessLevel(UNPRIVILIGE);
			OS_SWITCH_TO_UNPRIVILIGE;


			TaskA_Flag = TaskA(1,2,3);


			// Switch to (previlige)  syscall, the processor will interrupt itself to the handler mode
			OS_Generate_Exception;

			// Set SP to shadow to MSP
			OS_SWITCH_SP_to_MSP;

		}else if(TaskB_Flag == 1){
			// Set PSP register to point to the top of taskB_stack (_S_PSP_TB)
			OS_SET_PSP(_S_PSP_TB);

			// Set SP to shadow to PSP
			OS_SWITCH_SP_to_PSP;



			// Switch to user mode (unprevilige)
			//Switch_CPU_AccessLevel(UNPRIVILIGE);
			OS_SWITCH_TO_UNPRIVILIGE;


			TaskB_Flag = TaskB(1,2,3,4);


			// Switch to (previlige)
			OS_Generate_Exception;

			// Set SP to shadow to MSP
			OS_SWITCH_SP_to_MSP;

		}
	}


}


void OS_SVC_Services(int* StackFramePointer)
{
	// OS_SVC_Set stack --> r0 = argument 0 = StackFramePointer point on r0
	// OS_SVC_Set stack --> r0,r1,r2,r3,r12,lr,pc,xpsr

	unsigned char SVC_Number;
	unsigned int Val1, Val2;

    // get the svc number to form the svc instruction which generate the svc handler
	// r0 , r1 ,r2 ,r3 ,r12 , lr , pc== 6 index contain the instruction to execute after the svc handler  '-2' to get the instruction that activate the svc handler 2 byte
	SVC_Number = *((unsigned char*)(((unsigned char*)StackFramePointer[6]) - 2)); //(((unsigned char*)StackFramePointer[6]) - 2)) offset of to bytes ((unsigned char*) extract the first byte contain the number
	Val1 = StackFramePointer[0]; // r0
	Val2 = StackFramePointer[1]; // r1


	switch(SVC_Number) // depend on the number
	{
	case 1:
		StackFramePointer[0] = Val1 + Val2;
		break;

	case 2:
		StackFramePointer[0] = Val1 - Val2;
		break;

	case 3:
		StackFramePointer[0] = Val1 * Val2;
		break;

	case 4:
		SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk; // active the pendsv
	}

}


void PendSV_Handler()
{

}

// Consider it as C function, but don't push anything in stack and neglect the calling overhead , it is assembly, force the compiler to not add anything

__attribute ((naked))  void SVC_Handler()
{
	// Check EXC_Return to see if you were MSP or PSP
	__asm("tst lr,#4 \n\t" // test the third bit if its  1 or 0 to set the main stack  or the process stack
			"ITE EQ \n\t"
			"mrseq r0,MSP \n\t"
			"mrsne r0,PSP \n\t"
			"B OS_SVC_Services"); // branch to the os svc

}


int OS_SVC_Set(int a, int b, int SVC_ID)
{
	int result;
	switch(SVC_ID){
	case 1:  // Addition
		__asm("svc #0x01");
		break;

	case 2:  // Subtraction
		__asm("svc #0x02");
		break;

	case 3:  // Multiplication
		__asm("svc #0x03");
		break;

	case 4:  // PendSV
		__asm("svc #0x04");
		break;

	}
	__asm("mov %0,r0" : "=r"(result));
	return result;
}



int main(void)
{

	IRQ_Flag = OS_SVC_Set(5,  8, 3);  // Addition
	IRQ_Flag = OS_SVC_Set(3, 6, 2);	 // Subtraction
	IRQ_Flag = OS_SVC_Set(3, 1 , 1);  // Multiplication




}
